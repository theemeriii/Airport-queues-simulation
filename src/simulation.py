# -*- coding: utf-8 -*-
"""simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DimrUzT4JwjAfMHhRZsgcpoclc0BAKcc
"""

# All imports
import random
import numpy as np
import matplotlib.pyplot as plt
import heapq
from collections import deque
from scipy.stats import expon, uniform, bernoulli, truncnorm
from tqdm import tqdm
import scipy.stats as st
import unittest
from typing import Any

import heapq

class Event:
    '''
    Store the properties of one event in the Schedule class defined below. Each
    event has a time at which it needs to run, a function to call when running
    the event, along with the arguments and keyword arguments to pass to that
    function.
    '''
    def __init__(self, timestamp, function, log, *args, **kwargs):
        self.timestamp = timestamp
        self.function = function
        self.args = args
        self.kwargs = kwargs
        self.log = log

    def __lt__(self, other):
        '''
        This overloads the less-than operator in Python. We need it so the
        priority queue knows how to compare two events. We want events with
        earlier (smaller) times to go first.
        '''
        return self.timestamp < other.timestamp

    def run(self, schedule):
        '''
        Run an event by calling the function with its arguments and keyword
        arguments. The first argument to any event function is always the
        schedule in which events are being tracked. The schedule object can be
        used to add new events to the priority queue.
        '''
        self.function(schedule, *self.args, **self.kwargs)

class Schedule:
    '''
    Implement an event schedule using a priority queue. You can add events and
    run the next event.

    The `now` attribute contains the time at which the last event was run.
    '''

    def __init__(self, verbose=False):
        self.now = 0  # Keep track of the current simulation time
        self.priority_queue = []  # The priority queue of events to run
        self.verbose = verbose

    def add_event_at(self, timestamp, function, log, *args, **kwargs):
        # Add an event to the schedule at a particular point in time.
        heapq.heappush(
            self.priority_queue,
            Event(timestamp, function, log, *args, **kwargs))

    def add_event_after(self, interval, function, log, *args, **kwargs):
        # Add an event to the schedule after a specified time interval.
        self.add_event_at(self.now + interval, function, log, *args, **kwargs)

    def next_event_time(self):
        # Return the time of the next event. The `now` attribute of this class
        # contain the time of the last event that was run.
        return self.priority_queue[0].timestamp

    def run_next_event(self):
        # Get the next event from the priority queue and run it.
        event = heapq.heappop(self.priority_queue)
        self.now = event.timestamp
        event.run(self)
        if self.verbose:
          print(event.log)

    def __repr__(self):
        return (
            f'Schedule() at time {self.now} ' +
            f'with {len(self.priority_queue)} events in the queue')

    def print_events(self):
        # Print out diagnostic information about the events in the schedule.
        print(repr(self))
        for event in sorted(self.priority_queue):
            print(f'   {event.timestamp}: {event.function.__name__}')

class Passenger:
    """Represents a passenger with arrival, service, and departure details."""

    _counter = 1

    def __init__(self, arrival_time: float):
        self.arrival_time = arrival_time
        self.service_start_time: float | None = None
        self.departure_time: float | None = None
        self.additional_screening: bool | None = None
        self.name = f"passenger_{Passenger._counter}"

        Passenger._counter += 1

class Station:
    """A service station that processes passengers and tracks key performance metrics."""

    def __init__(
        self,
        station_name: str,
        senior_officer: 'SeniorOfficer',
        service_distribution,
        extra_screening_distribution
    ):
        self.station_name = station_name
        self.senior_officer = senior_officer
        self.service_distribution = service_distribution
        self.extra_screening_distribution = extra_screening_distribution

        # Server state
        self.queue_length: int = 0
        self.people_served: int = 0
        self.server_is_busy: bool = False
        self.passengers: deque = deque()

        self.total_busy_time: float = 0
        self.last_service_start: float | None = None

        # Statistics
        self.waiting_times: list[float] = []   # service_start_time - arrival_time
        self.response_times: list[float] = []  # departure_time - arrival_time
        self.service_times: list[float] = []   # departure_time - service_start_time

        self.queue_length_data: dict[str, list | int] = {
            "time": [0.0],
            "people_in_queue": [0],
            "max_queue_len": 0,
        }

    def handle_new_arrival_event(self, schedule):
        """Handles a new passenger arrival at this station."""
        new_passenger = Passenger(schedule.now)
        self.passengers.append(new_passenger)

        if not self.server_is_busy:
            schedule.add_event_after(
                0,
                self.start_service,
                log=f"{self.station_name}: {new_passenger.name} starts service",
            )

        self.queue_length += 1
        self._update_queue_data(schedule.now)

    def start_service(self, schedule):
        """Begins servicing the first passenger in the queue."""
        if self.queue_length > 0:
            self.queue_length -= 1
            self._update_queue_data(schedule.now)

        passenger = self.passengers[0]
        passenger.service_start_time = schedule.now
        self.last_service_start = schedule.now
        self.server_is_busy = True

        # Track statistics
        wait_time = schedule.now - passenger.arrival_time
        self.waiting_times.append(wait_time)
        self.people_served += 1

        # Schedule service completion
        service_time = self.service_distribution.rvs()
        schedule.add_event_after(
            service_time,
            self.end_service,
            log=f"t={schedule.now}, {self.station_name}: {passenger.name} ends service",
        )

    def end_service(self, schedule):
        """Handles passenger after completion of service (may need extra screening)."""
        passenger = self.passengers[0]
        passenger.additional_screening = self.extra_screening_distribution.rvs()

        if passenger.additional_screening:
            self.senior_officer.handle_additional_screening(schedule, self)
        else:
            schedule.add_event_after(
                0,
                self.on_departure,
                log=f"t={schedule.now}, {self.station_name}: {passenger.name} departs",
            )

    def on_departure(self, schedule):
        """Handles passenger departure and records metrics."""
        passenger = self.passengers.popleft()
        passenger.departure_time = schedule.now

        # Record statistics
        self.response_times.append(passenger.departure_time - passenger.arrival_time)
        self.service_times.append(passenger.departure_time - passenger.service_start_time)
        self.total_busy_time += schedule.now - self.last_service_start

        # Continue service if queue is not empty
        if self.queue_length > 0:
            next_passenger = self.passengers[0]
            schedule.add_event_after(
                0,
                self.start_service,
                log=f"t={schedule.now}, {self.station_name}: {next_passenger.name} starts service",
            )
        else:
            self.server_is_busy = False

    def _update_queue_data(self, now: float) -> None:
        """Updates queue metrics after an arrival or service start."""
        self.queue_length_data["time"].append(float(now))
        self.queue_length_data["people_in_queue"].append(self.queue_length)
        if self.queue_length > self.queue_length_data["max_queue_len"]:
            self.queue_length_data["max_queue_len"] = self.queue_length

class SeniorOfficer:
    """Represents a senior officer who handles additional screening at stations."""

    def __init__(self, schedule: Schedule, service_distribution):
        self.schedule = schedule
        self.service_distribution = service_distribution

        # State
        self.is_busy: bool = False
        self.queue: deque = deque()

        # Statistics
        self.service_start_times: list[float] = []
        self.service_end_times: list[float] = []

        self.queue_length_data: dict[str, list] = {
            "time": [],
            "busy_stations": [],
        }

    def handle_additional_screening(self, schedule: Any, station: Any) -> None:
        """Handles the arrival of a passenger requiring additional screening."""
        if self.is_busy:
            self.queue.append(station)
        else:
            self.start_service(schedule, station)

        self._record_queue_length(schedule.now)

    def start_service(self, schedule: Schedule, station: Station) -> None:
        """Begins additional screening for a station’s passenger."""
        self.is_busy = True
        self.service_start_times.append(schedule.now)

        service_time = self.service_distribution.rvs()
        self.schedule.add_event_after(
            service_time,
            self.end_service,
            log=f"t={self.schedule.now}, Senior Officer: {station.station_name} ends service",
            station=station,
        )

    def end_service(self, schedule: Schedule, station: Station) -> None:
        """Completes additional screening and proceeds with the passenger’s departure."""
        self.service_end_times.append(schedule.now)

        # Passenger departs after screening
        schedule.add_event_after(
            0,
            station.on_departure,
            log=f"t={schedule.now}, {station.station_name}: {station.passengers[0].name} departs",
        )

        # Check if there are more stations waiting
        if self.queue:
            next_station = self.queue.popleft()
            schedule.add_event_after(
                0,
                self.start_service,
                log=f"t={schedule.now}, Senior Officer: {next_station.station_name} starts service",
                station=next_station,
            )
        else:
            self.is_busy = False

        self._record_queue_length(schedule.now)

    def _record_queue_length(self, now: float) -> None:
        """Records the queue length along with the current simulation time."""
        self.queue_length_data["busy_stations"].append(len(self.queue))
        self.queue_length_data["time"].append(float(now))

class Airport:
    """Represents an airport with multiple screening stations and a senior officer."""

    def __init__(
        self,
        schedule: Schedule,
        arrival_distribution,
        queue_service_distribution,
        officer_service_distribution,
        extra_screening_distribution,
        num_of_stations: int,
    ):
        self.schedule = schedule
        self.arrival_distribution = arrival_distribution
        self.queue_service_distribution = queue_service_distribution
        self.officer_service_distribution = officer_service_distribution
        self.num_of_stations = num_of_stations
        self.cur_station_idx = 0


        # Create senior officer
        self.officer = SeniorOfficer(schedule, officer_service_distribution)

        # Initialize stations
        self.stations: list[Station] = [
            Station(
                station_name=f"Station {i+1}",
                senior_officer=self.officer,
                service_distribution=queue_service_distribution,
                extra_screening_distribution=extra_screening_distribution,
            )
            for i in range(num_of_stations)
        ]

    def arrival_event(self, schedule: Schedule) -> None:
        """Handles a new passenger arrival by assigning them to the shortest queue."""
        station = self.get_shortest_queue()
        station.handle_new_arrival_event(schedule)
        self.schedule_next_arrival(schedule)

    def get_random_station(self) -> Station:
        """Select a random station from the list of stations."""
        # this function was only used experimentation
        return random.choice(self.stations)


    def get_shortest_queue(self) -> Station:
        """Finds the station with the shortest queue (prioritizing idle servers)."""
        shortest = self.stations[0]

        for station in self.stations:
            if station.queue_length < shortest.queue_length:
                shortest = station
            elif (
                station.queue_length == shortest.queue_length == 0
                and not station.server_is_busy
                and shortest.server_is_busy
            ):
                # Prefer idle server if both have empty queues
                shortest = station

        return shortest

    def schedule_next_arrival(self, schedule: Schedule) -> None:
        """Schedules the next passenger arrival event using the arrival distribution."""
        arrival_interval = self.arrival_distribution.rvs()
        self.schedule.add_event_after(
            arrival_interval,
            self.arrival_event,
            log=f"t={schedule.now}, New arrival",
        )

# distributions
def truncated_normal(mu, sigma):
    lower = 0
    upper = float('inf')
    return truncnorm(
        (lower - mu) / sigma,
        (upper - mu) / sigma,
        loc=mu,
        scale=sigma)

# Arrival distribution (Poisson process with exponential inter-arrival times)
arrival_rate = 10  # average passengers per minute
arrival_distribution = expon(scale=1/ arrival_rate)

# Service times at the stations (truncated normal, units in minute)
service_mu = 30 / 60
service_sigma = 10 / 60
queue_service_distribution = truncated_normal(service_mu, service_sigma)

# Service times for senior officer (truncated normal, given in minutes)
officer_mu = 2     # mean 2 minutes
officer_sigma = 2  # std dev 2 minutes
officer_service_distribution = truncated_normal(officer_mu, officer_sigma)

# Extra screening probability (Bernoulli with p=3%)
p_extra_screening = 0.03
extra_screening_distribution = bernoulli(p_extra_screening)

# simulation to approximate the distribution of a passenger’s total service time (Z)

n_samples = 10000


station_service_times = queue_service_distribution.rvs(n_samples)

# Extra screening service times (only happens if flagged)
officer_service_times = officer_service_distribution.rvs(n_samples)

# Bernoulli trial -> whether extra screening occurs (1=yes, 0=no)
extra_screening_flags = np.random.binomial(1, p_extra_screening, size=n_samples)

# Total processing time = base service + (extra if flagged)
total_processing_times = station_service_times + extra_screening_flags * officer_service_times

mean_processing_time = np.mean(total_processing_times)
std_processing_time = np.std(total_processing_times)
min_processing_time = np.min(total_processing_times)
max_processing_time = np.max(total_processing_times)

print("\nPassenger Total Processing Time (Station + [Officer, with 3% probability]):")
print(f"Mean:     {mean_processing_time:.4f}")
print(f"Std Dev:  {std_processing_time:.4f}")
print(f"Min:      {min_processing_time:.4f}")
print(f"Max:      {max_processing_time:.4f}")

def run_airport_simulation(
    duration: int,
    num_stations: int,
    verbose: bool = False,
    progress_bar: bool = False,
) -> Airport:
    """
    Runs an airport checkpoint simulation until a specified time duration.

    Args:
        duration (int): Simulation end time.
        num_stations (int): Number of screening stations in the airport.
        verbose (bool): If True, the schedule will print detailed event logs.
        progress_bar (bool): If True, shows a progress bar for simulation time.

    Returns:
        Airport: The airport object containing stations, officer, and statistics.
    """

    # Initialize airport and event scheduler
    airport = Airport(
        schedule=Schedule(verbose=verbose),
        arrival_distribution=arrival_distribution,
        queue_service_distribution=queue_service_distribution,
        officer_service_distribution=officer_service_distribution,
        extra_screening_distribution=extra_screening_distribution,
        num_of_stations=num_stations,
    )

    # Trigger the first arrival event
    airport.schedule_next_arrival(airport.schedule)  # updated to match new naming

    # Progress bar setup (optional)
    pbar = tqdm(total=duration, disable=not progress_bar)
    last_shown_time = 0

    # Run events until simulation clock reaches duration
    while airport.schedule.next_event_time() <= duration:
        current_time = airport.schedule.now

        # Update progress bar (once per integer time unit)
        if progress_bar and int(current_time) > last_shown_time:
            pbar.n = int(current_time)
            pbar.refresh()
            last_shown_time = int(current_time)

        airport.schedule.run_next_event()

    # Finalize progress bar display
    if progress_bar:
        pbar.n = duration
        pbar.refresh()
        pbar.close()

    return airport

verbose = False
progress_bar = False
num_stations = 7
duration = 1000

airport = run_airport_simulation(duration, num_stations, verbose, progress_bar)

import numpy as np

def time_weighted_average_queue_length(event_times, queue_lengths, total_duration):
    """
    Compute the time-weighted average queue length from a piecewise-constant
    time series of (times, values).

    Equivalent to integrating queue length over time and dividing by total_duration.

    Args:
        times (list[float] | np.ndarray): Event times (monotonic or unsorted).
        values (list[int/float] | np.ndarray): Corresponding queue lengths.
        total_duration (float): The total duration over which to compute the average.

    Returns:
        float: Time-weighted average queue length.
    """
    # Validate input
    event_times = np.asarray(event_times, dtype=float)
    queue_lengths = np.asarray(queue_lengths, dtype=float)

    # Sort events by time (in case input is unsorted)
    sorted_indices = np.argsort(event_times)
    event_times = event_times[sorted_indices]
    queue_lengths = queue_lengths[sorted_indices]

    # Deduplicate times: if multiple events at the same time, keep the latest queue length
    dedup_times = [event_times[0]]
    dedup_lengths = [queue_lengths[0]]
    for current_time, current_length in zip(event_times[1:], queue_lengths[1:]):
        if current_time == dedup_times[-1]:
            dedup_lengths[-1] = current_length
        else:
            dedup_times.append(current_time)
            dedup_lengths.append(current_length)

    event_times = np.array(dedup_times)
    queue_lengths = np.array(dedup_lengths)

    # Ensure timeline starts at 0
    if event_times[0] > 0:
        event_times = np.insert(event_times, 0, 0.0)
        queue_lengths = np.insert(queue_lengths, 0, queue_lengths[0])

    # Truncate timeline to total_duration
    within_duration_mask = event_times <= total_duration
    event_times = event_times[within_duration_mask]
    queue_lengths = queue_lengths[within_duration_mask]

    # Ensure timeline ends at total_duration
    if event_times[-1] < total_duration:
        event_times = np.append(event_times, total_duration)
        queue_lengths = np.append(queue_lengths, queue_lengths[-1])

    # Compute integral via area under piecewise-constant curve
    time_intervals = np.diff(event_times)
    weighted_area = np.sum(queue_lengths[:-1] * time_intervals)

    return weighted_area / total_duration

# Collect data from all stations
all_waiting_times = []
all_response_times = []
all_service_times = []
total_busy_time_all = 0
mean_queue_lengths = []
max_queue_lengths = []

for station in airport.stations:
    all_waiting_times.extend(station.waiting_times)
    all_response_times.extend(station.response_times)
    all_service_times.extend(station.service_times)
    total_busy_time_all += station.total_busy_time


    mean_queue_lengths.append(
        time_weighted_average_queue_length(
            station.queue_length_data['time'],
            station.queue_length_data['people_in_queue'],
            duration
        )
    )
    max_queue_lengths.append(station.queue_length_data['max_queue_len'])

# Calculate system-wide metrics
num_stations = len(airport.stations)
avg_utilization = (total_busy_time_all / num_stations) / duration

print(f"=== System-Wide Metrics (averaged across all {num_stations} stations) ===")
print(f"Average waiting time: {np.mean(all_waiting_times):.2f} minutes")
print(f"Average response time: {np.mean(all_response_times):.2f} minutes")
print(f"Average service time: {np.mean(all_service_times):.2f} minutes")
print(f"Average utilization rate: {avg_utilization:.3f}")
print(f"Max queue length (across all stations): {max(max_queue_lengths)}")
print(f"Average queue length: {np.mean(mean_queue_lengths):.2f}")